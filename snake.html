<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cosmic Snake</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg1: #050816;
      --bg2: #120c2f;
      --accent1: #26f0ff;
      --accent2: #ff4ecd;
      --accent3: #ffe066;
      --accent4: #57ff9f;
      --danger: #ff5c5c;
      --text-main: #f8f9ff;
      --text-sub: #b3b6ff;
      --tile-bg: #15162b;
      --tile-border: #24274a;
      --btn-bg: rgba(15, 18, 40, 0.9);
      --btn-border: rgba(255, 255, 255, 0.08);
      --btn-hover: rgba(38, 240, 255, 0.16);
      --shadow-soft: 0 18px 45px rgba(0, 0, 0, 0.6);
      --radius-lg: 24px;
      --radius-md: 14px;
      --transition-fast: 0.18s ease-out;
      --transition-med: 0.25s ease-out;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      color: var(--text-main);
      background:
        radial-gradient(circle at 10% 0%, #1b1a55 0, transparent 55%),
        radial-gradient(circle at 90% 100%, #ff4ecd33 0, transparent 55%),
        radial-gradient(circle at 0% 100%, #26f0ff22 0, transparent 55%),
        radial-gradient(circle at 80% 0%, #ffe06622 0, transparent 55%),
        linear-gradient(135deg, var(--bg1), var(--bg2));
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    .game-shell {
      width: 100%;
      max-width: 980px;
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
      gap: 20px;
      backdrop-filter: blur(20px);
      background: linear-gradient(
        135deg,
        rgba(7, 10, 30, 0.94),
        rgba(13, 11, 40, 0.98)
      );
      border-radius: 28px;
      padding: 20px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: var(--shadow-soft);
    }

    @media (max-width: 840px) {
      .game-shell {
        grid-template-columns: minmax(0, 1fr);
        max-width: 640px;
      }
    }

    .game-panel {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .game-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
    }

    .title-wrap {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .title {
      font-size: 1.5rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 700;
      background: linear-gradient(120deg, var(--accent1), var(--accent2));
      -webkit-background-clip: text;
      color: transparent;
      text-shadow: 0 0 10px rgba(38, 240, 255, 0.6);
    }

    .subtitle {
      font-size: 0.82rem;
      color: var(--text-sub);
      opacity: 0.95;
    }

    .badge {
      padding: 4px 9px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      font-size: 0.74rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--accent3);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: linear-gradient(
        120deg,
        rgba(255, 255, 255, 0.03),
        rgba(255, 255, 255, 0.01)
      );
    }

    .badge-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 0%, #fff, var(--accent3));
      box-shadow: 0 0 6px rgba(255, 224, 102, 0.7);
    }

    .score-strip {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
      margin-top: 8px;
    }

    .score-card {
      padding: 8px 10px;
      border-radius: 16px;
      background: radial-gradient(circle at 0 0, #26f0ff22, #070818 60%);
      border: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      flex-direction: column;
      gap: 3px;
      min-width: 0;
    }

    .score-card:nth-child(2) {
      background: radial-gradient(circle at 100% 0, #ff4ecd22, #070818 60%);
    }

    .score-card:nth-child(3) {
      background: radial-gradient(circle at 0 100%, #ffe06622, #070818 60%);
    }

    .score-card:nth-child(4) {
      background: radial-gradient(circle at 100% 100%, #57ff9f22, #070818 60%);
    }

    .score-label {
      font-size: 0.68rem;
      text-transform: uppercase;
      letter-spacing: 0.13em;
      color: var(--text-sub);
      opacity: 0.9;
    }

    .score-value {
      font-size: 1.05rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .score-chip {
      padding: 0 6px;
      border-radius: 999px;
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      border: 1px solid rgba(255, 255, 255, 0.14);
      color: var(--accent1);
      background: rgba(8, 14, 40, 0.86);
    }

    .canvas-wrap {
      margin-top: 10px;
      border-radius: var(--radius-lg);
      padding: 10px;
      background:
        radial-gradient(circle at 0 0, rgba(38, 240, 255, 0.32), transparent 50%),
        radial-gradient(circle at 100% 100%, rgba(255, 78, 205, 0.38), transparent 50%),
        linear-gradient(145deg, #050818, #14112b);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.06),
        0 16px 40px rgba(0, 0, 0, 0.9);
      position: relative;
      overflow: hidden;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: auto;
      border-radius: 18px;
      background: radial-gradient(circle at 20% 0, #1b1f3b, #050614 60%);
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
    }

    .scanline {
      pointer-events: none;
      position: absolute;
      inset: 12px;
      border-radius: 16px;
      background-image: linear-gradient(
        to bottom,
        rgba(255, 255, 255, 0.06) 1px,
        transparent 1px
      );
      background-size: 100% 3px;
      mix-blend-mode: soft-light;
      opacity: 0.15;
    }

    .overlay {
      position: absolute;
      inset: 10px;
      border-radius: 18px;
      background: radial-gradient(circle at 50% 0, #050818dd, #050614f5);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 14px;
      text-align: center;
      padding: 24px 18px;
      z-index: 4;
      transition: opacity var(--transition-med), visibility var(--transition-med);
    }

    .overlay.hidden {
      opacity: 0;
      visibility: hidden;
    }

    .overlay-title {
      font-size: 1.4rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      font-weight: 700;
      background: linear-gradient(120deg, var(--accent1), var(--accent2));
      -webkit-background-clip: text;
      color: transparent;
      text-shadow: 0 0 18px rgba(99, 252, 255, 0.6);
    }

    .overlay-subtitle {
      font-size: 0.9rem;
      color: var(--text-sub);
      max-width: 360px;
    }

    .overlay-subtitle span {
      color: var(--accent4);
      font-weight: 500;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin-top: 4px;
    }

    .btn {
      border-radius: 999px;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg);
      padding: 7px 14px;
      font-size: 0.8rem;
      color: var(--text-main);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: background var(--transition-fast),
        transform var(--transition-fast),
        box-shadow var(--transition-fast),
        border-color var(--transition-fast);
      white-space: nowrap;
    }

    .btn-primary {
      background: radial-gradient(circle at 0 0, var(--accent1), var(--accent2));
      border-color: rgba(255, 255, 255, 0.2);
      color: #020411;
      font-weight: 600;
      box-shadow: 0 10px 26px rgba(38, 240, 255, 0.55);
    }

    .btn-primary:hover {
      transform: translateY(-1px) translateZ(0);
      box-shadow: 0 12px 30px rgba(38, 240, 255, 0.7);
    }

    .btn-ghost {
      background: rgba(9, 12, 36, 0.9);
    }

    .btn:hover {
      background: var(--btn-hover);
      border-color: rgba(255, 255, 255, 0.18);
    }

    .btn:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    .kbd {
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.16);
      padding: 1px 4px;
      font-size: 0.7rem;
      background: rgba(3, 7, 25, 0.86);
      color: var(--accent1);
    }

    .hint {
      font-size: 0.76rem;
      color: var(--text-sub);
      opacity: 0.95;
      margin-top: 6px;
    }

    .hint span {
      color: var(--accent2);
    }

    /* Right panel */
    .info-panel {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .info-card {
      border-radius: var(--radius-md);
      padding: 12px 12px 12px 13px;
      background: radial-gradient(circle at 0 0, #26f0ff11, #050816f5);
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.6);
    }

    .info-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-sub);
      margin-bottom: 6px;
    }

    .pill-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 5px;
    }

    .pill {
      border-radius: 999px;
      padding: 3px 9px;
      font-size: 0.72rem;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(5, 8, 28, 0.9);
      color: var(--text-sub);
      display: inline-flex;
      align-items: center;
      gap: 5px;
    }

    .pill-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
    }

    .pill-dot.food {
      background: radial-gradient(circle at 0 0, #fff, var(--accent2));
      box-shadow: 0 0 8px rgba(255, 78, 205, 0.7);
    }

    .pill-dot.power {
      background: radial-gradient(circle at 0 0, #fff, var(--accent3));
      box-shadow: 0 0 9px rgba(255, 224, 102, 0.7);
    }

    .pill-dot.slow {
      background: radial-gradient(circle at 0 0, #fff, #57ff9f);
      box-shadow: 0 0 9px rgba(87, 255, 159, 0.7);
    }

    .pill-dot.danger {
      background: radial-gradient(circle at 0 0, #fff, var(--danger));
      box-shadow: 0 0 9px rgba(255, 92, 92, 0.7);
    }

    .info-list {
      list-style: none;
      font-size: 0.78rem;
      color: var(--text-sub);
      display: grid;
      gap: 3px;
      margin-top: 4px;
    }

    .info-list li span {
      color: var(--accent1);
      font-weight: 500;
    }

    .toggle-row {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      padding: 4px 9px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(5, 8, 28, 0.9);
      font-size: 0.75rem;
      cursor: pointer;
      color: var(--text-sub);
      transition: background var(--transition-fast),
        border-color var(--transition-fast),
        box-shadow var(--transition-fast),
        transform var(--transition-fast);
    }

    .toggle input {
      appearance: none;
      width: 18px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.22);
      position: relative;
      background: rgba(10, 13, 40, 0.95);
      outline: none;
      cursor: pointer;
    }

    .toggle input::after {
      content: "";
      position: absolute;
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #fff;
      top: 1px;
      left: 1px;
      transition: transform 0.18s ease-out;
      box-shadow: 0 0 4px rgba(255, 255, 255, 0.7);
    }

    .toggle input:checked {
      background: linear-gradient(90deg, var(--accent1), var(--accent2));
      border-color: rgba(255, 255, 255, 0.45);
    }

    .toggle input:checked::after {
      transform: translateX(7px);
    }

    .toggle.active {
      border-color: rgba(38, 240, 255, 0.7);
      box-shadow: 0 0 14px rgba(38, 240, 255, 0.35);
      color: var(--accent1);
    }

    .tiny-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--text-sub);
      margin-top: 6px;
      opacity: 0.85;
    }

    /* Mobile controls */
    .controls-panel {
      margin-top: 10px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: radial-gradient(circle at 0 0, #26f0ff11, #050816fb);
      padding: 8px 10px 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .controls-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
    }

    .controls-header span {
      font-size: 0.8rem;
      color: var(--text-sub);
    }

    .control-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      width: 100%;
      max-width: 260px;
      margin: 0 auto;
      touch-action: manipulation;
    }

    .control-btn {
      width: 100%;
      aspect-ratio: 1 / 1;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: radial-gradient(circle at 30% 0, #26f0ff22, #050816);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-main);
      font-size: 1.1rem;
      cursor: pointer;
      transition: background var(--transition-fast),
        transform var(--transition-fast),
        box-shadow var(--transition-fast),
        border-color var(--transition-fast);
    }

    .control-btn.empty {
      visibility: hidden;
    }

    .control-btn:hover {
      background: radial-gradient(circle at 30% 0, #26f0ff44, #050816);
      border-color: rgba(38, 240, 255, 0.7);
      box-shadow: 0 0 18px rgba(38, 240, 255, 0.4);
      transform: translateY(-1px);
    }

    .control-btn:active {
      transform: translateY(1px) scale(0.97);
      box-shadow: none;
    }

    .controls-footer {
      font-size: 0.72rem;
      color: var(--text-sub);
      text-align: center;
    }

    .controls-footer span {
      color: var(--accent4);
    }

    @media (min-width: 840px) {
      .controls-panel {
        margin-top: 6px;
      }
    }

    @media (max-width: 580px) {
      .game-shell {
        padding: 16px;
        border-radius: 20px;
      }
      .canvas-wrap {
        padding: 8px;
      }
      .overlay-title {
        font-size: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <div class="game-shell">
    <div class="game-panel">
      <div class="game-header">
        <div class="title-wrap">
          <div class="title">Cosmic Snake</div>
          <div class="subtitle">Bend space, chase starlight, and don’t bite your own tail.</div>
        </div>
        <div class="badge">
          <span class="badge-dot"></span>
          <span>Arcade · Infinite Grid</span>
        </div>
      </div>

      <div class="score-strip">
        <div class="score-card">
          <div class="score-label">Score</div>
          <div class="score-value">
            <span id="score">0</span>
            <span class="score-chip">Live</span>
          </div>
        </div>
        <div class="score-card">
          <div class="score-label">Best Run</div>
          <div class="score-value">
            <span id="bestScore">0</span>
            <span class="score-chip">All Time</span>
          </div>
        </div>
        <div class="score-card">
          <div class="score-label">Mode</div>
          <div class="score-value">
            <span id="modeLabel">Wrap</span>
            <span class="score-chip" id="difficultyLabel">Chill</span>
          </div>
        </div>
        <div class="score-card">
          <div class="score-label">Speed</div>
          <div class="score-value">
            <span id="speedLabel">1x</span>
            <span class="score-chip">Pace</span>
          </div>
        </div>
      </div>

      <div class="canvas-wrap">
        <canvas id="gameCanvas" width="480" height="480"></canvas>
        <div class="scanline"></div>

        <div class="overlay" id="overlay">
          <div class="overlay-title" id="overlayTitle">Tap Play to Enter Orbit</div>
          <div class="overlay-subtitle" id="overlaySubtitle">
            Eat <span>pink stars</span> to grow. Collect golden power-ups for
            cosmic boosts. Don’t collide with yourself – or the walls in
            <span>Classic</span> mode.
          </div>
          <div class="btn-row">
            <button class="btn btn-primary" id="playButton">
              ▶ Play
            </button>
            <button class="btn btn-ghost" id="pauseHintButton">
              ⏸ Press <span class="kbd">Space</span> to Pause
            </button>
          </div>
          <div class="hint">
            Move with <span>WASD</span> / <span>Arrow keys</span> or the on-screen controls.
          </div>
        </div>
      </div>

      <div class="controls-panel">
        <div class="controls-header">
          <span>Touch controls</span>
          <button class="btn btn-ghost" id="restartButton" style="padding:4px 10px;font-size:0.72rem;">
            ⟳ Restart
          </button>
        </div>
        <div class="control-grid">
          <div class="control-btn empty"></div>
          <button class="control-btn" data-dir="up">▲</button>
          <div class="control-btn empty"></div>

          <button class="control-btn" data-dir="left">◀</button>
          <div class="control-btn empty"></div>
          <button class="control-btn" data-dir="right">▶</button>

          <div class="control-btn empty"></div>
          <button class="control-btn" data-dir="down">▼</button>
          <div class="control-btn empty"></div>
        </div>
        <div class="controls-footer">
          Tip: As you eat, the game gently speeds up. <span>Stay smooth.</span>
        </div>
      </div>
    </div>

    <div class="info-panel">
      <div class="info-card">
        <div class="info-title">Power-ups & Hazards</div>
        <div class="pill-row">
          <div class="pill">
            <span class="pill-dot food"></span>
            Pink Star · +1
          </div>
          <div class="pill">
            <span class="pill-dot power"></span>
            Golden Core · +5 & speed burst
          </div>
          <div class="pill">
            <span class="pill-dot slow"></span>
            Mint Orb · Slow time
          </div>
          <div class="pill">
            <span class="pill-dot danger"></span>
            Glitch Cell · Instantly grows (careful!)
          </div>
        </div>
        <ul class="info-list">
          <li><span>Pink</span> food: classic growth & score.</li>
          <li><span>Gold</span> stars: big points and a little adrenaline.</li>
          <li><span>Mint</span> orbs: briefly calm the tempo.</li>
          <li><span>Glitch</span> tiles: jump-growth — great for points, risky in tight spaces.</li>
        </ul>
      </div>

      <div class="info-card">
        <div class="info-title">Modes & Controls</div>
        <ul class="info-list">
          <li><span>Wrap</span> mode: slide through one edge and appear on the other.</li>
          <li><span>Classic</span> mode: walls are solid. Old-school danger.</li>
          <li><span>Pause</span> anytime with the space bar.</li>
          <li><span>Restart</span> with the ⟳ button or <span class="kbd">R</span>.</li>
        </ul>
        <div class="toggle-row">
          <label class="toggle" id="modeToggleLabel">
            <input type="checkbox" id="modeToggle" />
            <span>Classic walls</span>
          </label>
          <label class="toggle" id="soundToggleLabel">
            <input type="checkbox" id="soundToggle" checked />
            <span>Soft effects</span>
          </label>
        </div>
        <div class="tiny-label">Difficulty gently rises as you eat more stars.</div>
      </div>

      <div class="info-card">
        <div class="info-title">How to Win (You Can’t… But Try)</div>
        <ul class="info-list">
          <li><span>Think ahead</span> — avoid boxing yourself in.</li>
          <li><span>Use slow-mo</span> to thread tight gaps.</li>
          <li><span>Chain power-ups</span> for huge scores.</li>
          <li><span>Chill</span> — the grid is infinite in wrap mode.</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      const overlay = document.getElementById("overlay");
      const overlayTitle = document.getElementById("overlayTitle");
      const overlaySubtitle = document.getElementById("overlaySubtitle");
      const playButton = document.getElementById("playButton");
      const pauseHintButton = document.getElementById("pauseHintButton");
      const restartButton = document.getElementById("restartButton");

      const scoreEl = document.getElementById("score");
      const bestScoreEl = document.getElementById("bestScore");
      const modeLabel = document.getElementById("modeLabel");
      const difficultyLabel = document.getElementById("difficultyLabel");
      const speedLabel = document.getElementById("speedLabel");

      const modeToggle = document.getElementById("modeToggle");
      const modeToggleLabel = document.getElementById("modeToggleLabel");
      const soundToggle = document.getElementById("soundToggle");
      const soundToggleLabel = document.getElementById("soundToggleLabel");

      const controlButtons = document.querySelectorAll(".control-btn[data-dir]");

      const GRID_SIZE = 20;
      const TILE = canvas.width / GRID_SIZE;

      const INITIAL_SPEED = 140;
      const MIN_SPEED = 65;

      const POWERUP_CHANCE = 0.12;
      const POWERUP_DURATION = 5000;

      const STORAGE_KEY = "cosmicSnakeHighScoreV1";

      const STATE = {
        IDLE: "idle",
        RUNNING: "running",
        PAUSED: "paused",
        OVER: "over",
      };

      const POWER_TYPES = {
        GOLD: "gold",
        SLOW: "slow",
        GLITCH: "glitch",
      };

      let state = STATE.IDLE;
      let snake;
      let direction;
      let nextDirection;
      let food;
      let powerUp = null;
      let score = 0;
      let bestScore = 0;
      let speed = INITIAL_SPEED;
      let lastStepTime = 0;
      let isClassicWalls = false;
      let isSlowMoActive = false;
      let slowMoTimeoutId = null;
      let lastMoveSoundTime = 0;

      function loadBestScore() {
        try {
          const stored = localStorage.getItem(STORAGE_KEY);
          if (stored != null) {
            bestScore = parseInt(stored, 10) || 0;
          }
        } catch (e) {
          bestScore = 0;
        }
        bestScoreEl.textContent = bestScore;
      }

      function saveBestScore() {
        try {
          localStorage.setItem(STORAGE_KEY, String(bestScore));
        } catch (e) {}
      }

      function resetSnake() {
        const startX = Math.floor(GRID_SIZE / 2);
        const startY = Math.floor(GRID_SIZE / 2);
        snake = [
          { x: startX, y: startY },
          { x: startX - 1, y: startY },
          { x: startX - 2, y: startY },
        ];
        direction = { x: 1, y: 0 };
        nextDirection = { x: 1, y: 0 };
      }

      function spawnFood(exclude = []) {
        let pos;
        do {
          pos = {
            x: Math.floor(Math.random() * GRID_SIZE),
            y: Math.floor(Math.random() * GRID_SIZE),
          };
        } while (
          snake.some((s) => s.x === pos.x && s.y === pos.y) ||
          (powerUp && powerUp.x === pos.x && powerUp.y === pos.y) ||
          exclude.some((p) => p.x === pos.x && p.y === pos.y)
        );
        food = pos;
      }

      function spawnPowerUp() {
        if (Math.random() > POWERUP_CHANCE) return;
        const types = Object.values(POWER_TYPES);
        const type = types[Math.floor(Math.random() * types.length)];

        let pos;
        do {
          pos = {
            x: Math.floor(Math.random() * GRID_SIZE),
            y: Math.floor(Math.random() * GRID_SIZE),
          };
        } while (
          snake.some((s) => s.x === pos.x && s.y === pos.y) ||
          (food && food.x === pos.x && food.y === pos.y)
        );

        powerUp = {
          x: pos.x,
          y: pos.y,
          type,
          expiresAt: performance.now() + POWERUP_DURATION * (type === POWER_TYPES.GLITCH ? 0.7 : 1),
        };
      }

      function clearPowerUp() {
        powerUp = null;
      }

      function setState(newState) {
        state = newState;
        if (state === STATE.RUNNING) {
          overlay.classList.add("hidden");
        } else if (state === STATE.IDLE) {
          overlayTitle.textContent = "Tap Play to Enter Orbit";
          overlaySubtitle.innerHTML =
            'Eat <span>pink stars</span> to grow. Collect golden power-ups for cosmic boosts. Don’t collide with yourself – or the walls in <span>Classic</span> mode.';
          overlay.classList.remove("hidden");
        } else if (state === STATE.PAUSED) {
          overlayTitle.textContent = "Paused in Deep Space";
          overlaySubtitle.innerHTML =
            "Stretch your fingers. When you're ready, press <span>Space</span> or hit <span>Play</span> again to unfreeze the cosmos.";
          overlay.classList.remove("hidden");
        } else if (state === STATE.OVER) {
          overlayTitle.textContent = "You Folded Space Into Yourself";
          overlaySubtitle.innerHTML =
            `Final score: <span>${score}</span>. Press <span>Play</span> or hit <span>R</span> to jump into a new timeline.`;
          overlay.classList.remove("hidden");
        }
      }

      function resetGame() {
        resetSnake();
        score = 0;
        scoreEl.textContent = score;
        speed = INITIAL_SPEED;
        speedLabel.textContent = "1x";
        updateDifficultyLabel();
        clearPowerUp();
        spawnFood();
        setState(STATE.IDLE);
        lastStepTime = performance.now();
      }

      function startGame() {
        if (state === STATE.RUNNING) return;
        if (state === STATE.OVER || state === STATE.IDLE) {
          resetGame();
        }
        lastStepTime = performance.now();
        setState(STATE.RUNNING);
      }

      function pauseGame() {
        if (state !== STATE.RUNNING) return;
        setState(STATE.PAUSED);
      }

      function resumeGame() {
        if (state !== STATE.PAUSED) return;
        lastStepTime = performance.now();
        setState(STATE.RUNNING);
      }

      function gameOver() {
        setState(STATE.OVER);
        if (score > bestScore) {
          bestScore = score;
          bestScoreEl.textContent = bestScore;
          saveBestScore();
        }
      }

      function changeDirection(dir) {
        if (state !== STATE.RUNNING && state !== STATE.IDLE && state !== STATE.PAUSED)
          return;

        let newDir;
        if (dir === "up") newDir = { x: 0, y: -1 };
        else if (dir === "down") newDir = { x: 0, y: 1 };
        else if (dir === "left") newDir = { x: -1, y: 0 };
        else if (dir === "right") newDir = { x: 1, y: 0 };
        else return;

        if (snake.length > 1) {
          if (
            newDir.x === -direction.x &&
            newDir.y === -direction.y
          ) {
            return;
          }
        }

        nextDirection = newDir;
      }

      function playSoftClick() {
        if (!soundToggle.checked) return;
        const now = performance.now();
        if (now - lastMoveSoundTime < 80) return;
        lastMoveSoundTime = now;

        try {
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = "triangle";
          osc.frequency.value = 260 + Math.random() * 40;
          gain.gain.value = 0.08;
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          osc.start();
          osc.stop(audioCtx.currentTime + 0.06);
          osc.onended = () => audioCtx.close();
        } catch (e) {}
      }

      function playEatSound(big = false) {
        if (!soundToggle.checked) return;
        try {
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = "sine";
          osc.frequency.value = big ? 540 : 420;
          gain.gain.value = big ? 0.18 : 0.12;
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          osc.start();
          osc.stop(audioCtx.currentTime + 0.1);
          osc.onended = () => audioCtx.close();
        } catch (e) {}
      }

      function updateScore(points) {
        score += points;
        scoreEl.textContent = score;

        const scoreCard = scoreEl.closest(".score-card");
        scoreCard.style.transform = "scale(1.06)";
        scoreCard.style.transition = "transform 80ms ease-out";
        setTimeout(() => {
          scoreCard.style.transform = "scale(1)";
        }, 90);

        const levelFactor = Math.min(1.4, 1 + score / 60);
        const targetSpeed = Math.max(MIN_SPEED, INITIAL_SPEED / levelFactor);
        speed = targetSpeed;

        const speedMultiplier = (INITIAL_SPEED / speed).toFixed(1);
        speedLabel.textContent = `${speedMultiplier}x`;

        updateDifficultyLabel();
      }

      function updateDifficultyLabel() {
        const m = INITIAL_SPEED / speed;
        let label;
        if (m < 1.25) label = "Chill";
        else if (m < 1.6) label = "Focus";
        else if (m < 2.0) label = "Sweaty";
        else label = "Ludicrous";
        difficultyLabel.textContent = label;
      }

      function step() {
        direction = nextDirection;
        const head = { ...snake[0] };
        head.x += direction.x;
        head.y += direction.y;

        if (isClassicWalls) {
          if (
            head.x < 0 ||
            head.x >= GRID_SIZE ||
            head.y < 0 ||
            head.y >= GRID_SIZE
          ) {
            gameOver();
            return;
          }
        } else {
          if (head.x < 0) head.x = GRID_SIZE - 1;
          if (head.x >= GRID_SIZE) head.x = 0;
          if (head.y < 0) head.y = GRID_SIZE - 1;
          if (head.y >= GRID_SIZE) head.y = 0;
        }

        if (snake.some((segment) => segment.x === head.x && segment.y === head.y)) {
          gameOver();
          return;
        }

        snake.unshift(head);

        let ateFood = food && head.x === food.x && head.y === food.y;
        if (ateFood) {
          playEatSound(false);
          updateScore(1);
          spawnFood();
          if (!powerUp && Math.random() < POWERUP_CHANCE) {
            spawnPowerUp();
          }
        } else {
          snake.pop();
        }

        if (powerUp && head.x === powerUp.x && head.y === powerUp.y) {
          const type = powerUp.type;
          if (type === POWER_TYPES.GOLD) {
            playEatSound(true);
            updateScore(5);
            speed = Math.max(MIN_SPEED * 0.85, speed * 0.8);
          } else if (type === POWER_TYPES.SLOW) {
            playEatSound(false);
            isSlowMoActive = true;
            speed = INITIAL_SPEED * 1.35;
            if (slowMoTimeoutId) clearTimeout(slowMoTimeoutId);
            slowMoTimeoutId = setTimeout(() => {
              isSlowMoActive = false;
              const levelFactor = Math.min(1.4, 1 + score / 60);
              speed = Math.max(MIN_SPEED, INITIAL_SPEED / levelFactor);
            }, POWERUP_DURATION);
          } else if (type === POWER_TYPES.GLITCH) {
            playEatSound(true);
            const bonusSegments = 3 + Math.floor(Math.random() * 4);
            const tail = snake[snake.length - 1];
            for (let i = 0; i < bonusSegments; i++) {
              snake.push({ x: tail.x, y: tail.y });
            }
            updateScore(2);
          }
          clearPowerUp();
        }

        if (powerUp && performance.now() > powerUp.expiresAt) {
          clearPowerUp();
        }
      }

      function drawGrid() {
        const gradientBg = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradientBg.addColorStop(0, "#0a0d1f");
        gradientBg.addColorStop(1, "#050612");
        ctx.fillStyle = gradientBg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const gridGrad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gridGrad.addColorStop(0, "rgba(38, 240, 255, 0.18)");
        gridGrad.addColorStop(0.5, "rgba(255, 78, 205, 0.08)");
        gridGrad.addColorStop(1, "rgba(255, 224, 102, 0.16)");

        ctx.strokeStyle = gridGrad;
        ctx.lineWidth = 0.7;
        ctx.beginPath();
        for (let x = 0; x <= GRID_SIZE; x++) {
          const px = x * TILE;
          ctx.moveTo(px + 0.5, 0);
          ctx.lineTo(px + 0.5, canvas.height);
        }
        for (let y = 0; y <= GRID_SIZE; y++) {
          const py = y * TILE;
          ctx.moveTo(0, py + 0.5);
          ctx.lineTo(canvas.width, py + 0.5);
        }
        ctx.stroke();
      }

      function drawSnake() {
        if (!snake || snake.length === 0) return;

        const head = snake[0];
        const bodyGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        bodyGradient.addColorStop(0, "#26f0ff");
        bodyGradient.addColorStop(1, "#57ff9f");

        for (let i = snake.length - 1; i >= 0; i--) {
          const seg = snake[i];
          const x = seg.x * TILE;
          const y = seg.y * TILE;
          const radius = TILE * 0.32;

          const ratio = i / (snake.length - 1 || 1);
          const alpha = 0.3 + 0.7 * (1 - ratio);

          if (i === 0) {
            const headGrad = ctx.createRadialGradient(
              x + TILE * 0.3,
              y + TILE * 0.3,
              TILE * 0.2,
              x + TILE / 2,
              y + TILE / 2,
              TILE * 0.7
            );
            headGrad.addColorStop(0, "#ffffff");
            headGrad.addColorStop(0.2, "#26f0ff");
            headGrad.addColorStop(1, "#1b1f3b");

            ctx.fillStyle = headGrad;
            ctx.beginPath();
            ctx.roundRect(
              x + TILE * 0.16,
              y + TILE * 0.16,
              TILE * 0.7,
              TILE * 0.7,
              radius
            );
            ctx.fill();

            const eyeSize = TILE * 0.12;
            ctx.fillStyle = "#02030b";
            let eyeOffsetX1 = TILE * 0.18;
            let eyeOffsetX2 = TILE * 0.18;
            let eyeOffsetY1 = TILE * 0.18;
            let eyeOffsetY2 = TILE * 0.18;

            if (direction.x === 1) {
              eyeOffsetX1 = TILE * 0.35;
              eyeOffsetX2 = TILE * 0.35;
              eyeOffsetY1 = TILE * 0.2;
              eyeOffsetY2 = TILE * 0.52;
            } else if (direction.x === -1) {
              eyeOffsetX1 = TILE * 0.05;
              eyeOffsetX2 = TILE * 0.05;
              eyeOffsetY1 = TILE * 0.2;
              eyeOffsetY2 = TILE * 0.52;
            } else if (direction.y === 1) {
              eyeOffsetX1 = TILE * 0.2;
              eyeOffsetX2 = TILE * 0.52;
              eyeOffsetY1 = TILE * 0.35;
              eyeOffsetY2 = TILE * 0.35;
            } else if (direction.y === -1) {
              eyeOffsetX1 = TILE * 0.2;
              eyeOffsetX2 = TILE * 0.52;
              eyeOffsetY1 = TILE * 0.05;
              eyeOffsetY2 = TILE * 0.05;
            }

            ctx.beginPath();
            ctx.arc(x + eyeOffsetX1, y + eyeOffsetY1, eyeSize, 0, Math.PI * 2);
            ctx.arc(x + eyeOffsetX2, y + eyeOffsetY2, eyeSize, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "#26f0ff";
            ctx.beginPath();
            ctx.arc(x + eyeOffsetX1, y + eyeOffsetY1, eyeSize * 0.4, 0, Math.PI * 2);
            ctx.arc(x + eyeOffsetX2, y + eyeOffsetY2, eyeSize * 0.4, 0, Math.PI * 2);
            ctx.fill();
          } else {
            ctx.globalAlpha = alpha;
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.roundRect(
              x + TILE * 0.2,
              y + TILE * 0.2,
              TILE * 0.6,
              TILE * 0.6,
              radius * 0.8
            );
            ctx.fill();
            ctx.globalAlpha = 1;
          }
        }

        const headX = head.x * TILE + TILE / 2;
        const headY = head.y * TILE + TILE / 2;
        const glow = ctx.createRadialGradient(
          headX,
          headY,
          TILE * 0.2,
          headX,
          headY,
          TILE
        );
        glow.addColorStop(0, "rgba(38, 240, 255, 0.54)");
        glow.addColorStop(1, "rgba(38, 240, 255, 0)");
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(headX, headY, TILE * 1.1, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawFood() {
        if (!food) return;
        const x = food.x * TILE;
        const y = food.y * TILE;

        const grad = ctx.createRadialGradient(
          x + TILE * 0.25,
          y + TILE * 0.25,
          TILE * 0.1,
          x + TILE / 2,
          y + TILE / 2,
          TILE * 0.6
        );
        grad.addColorStop(0, "#ffffff");
        grad.addColorStop(0.2, "#ffb3ea");
        grad.addColorStop(1, "#ff4ecd");

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.roundRect(
          x + TILE * 0.25,
          y + TILE * 0.25,
          TILE * 0.5,
          TILE * 0.5,
          TILE * 0.2
        );
        ctx.fill();

        const twinkle = ctx.createRadialGradient(
          x + TILE / 2,
          y + TILE / 2,
          0,
          x + TILE / 2,
          y + TILE / 2,
          TILE
        );
        twinkle.addColorStop(0, "rgba(255, 78, 205, 0.6)");
        twinkle.addColorStop(1, "rgba(255, 78, 205, 0)");
        ctx.fillStyle = twinkle;
        ctx.beginPath();
        ctx.arc(x + TILE / 2, y + TILE / 2, TILE * 0.9, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawPowerUp() {
        if (!powerUp) return;
        const x = powerUp.x * TILE;
        const y = powerUp.y * TILE;

        let innerColor;
        let outerColor;
        if (powerUp.type === POWER_TYPES.GOLD) {
          innerColor = "#fff7c4";
          outerColor = "#ffe066";
        } else if (powerUp.type === POWER_TYPES.SLOW) {
          innerColor = "#e5fff5";
          outerColor = "#57ff9f";
        } else {
          innerColor = "#ffe0e0";
          outerColor = "#ff5c5c";
        }

        const grad = ctx.createRadialGradient(
          x + TILE * 0.3,
          y + TILE * 0.3,
          TILE * 0.1,
          x + TILE / 2,
          y + TILE / 2,
          TILE * 0.7
        );
        grad.addColorStop(0, innerColor);
        grad.addColorStop(1, outerColor);

        ctx.save();
        const t = performance.now() / 500;
        const scale = 0.65 + Math.sin(t * 2) * 0.07;

        ctx.translate(x + TILE / 2, y + TILE / 2);
        ctx.rotate(Math.sin(t) * 0.3);

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.roundRect(
          (-TILE * scale) / 2,
          (-TILE * scale) / 2,
          TILE * scale,
          TILE * scale,
          TILE * 0.28
        );
        ctx.fill();

        const ring = ctx.createRadialGradient(0, 0, TILE * 0.3, 0, 0, TILE);
        ring.addColorStop(0, outerColor.replace(")", ",0.5)").replace("#", "rgba("));
        ring.addColorStop(1, "rgba(0,0,0,0)");

        ctx.restore();
      }

      function draw() {
        drawGrid();
        drawFood();
        drawPowerUp();
        drawSnake();

        if (state !== STATE.RUNNING && state !== STATE.PAUSED) {
          const fade = ctx.createLinearGradient(0, 0, 0, canvas.height);
          fade.addColorStop(0, "rgba(0, 0, 0, 0.4)");
          fade.addColorStop(1, "rgba(0, 0, 0, 0.55)");
          ctx.fillStyle = fade;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      }

      function loop(timestamp) {
        if (!lastStepTime) lastStepTime = timestamp;
        const delta = timestamp - lastStepTime;

        if (state === STATE.RUNNING) {
          if (delta >= speed) {
            lastStepTime = timestamp;
            step();
          }
        }

        draw();
        requestAnimationFrame(loop);
      }

      document.addEventListener("keydown", (e) => {
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key)) {
          e.preventDefault();
        }

        if (e.key === "ArrowUp" || e.key.toLowerCase() === "w") {
          changeDirection("up");
          playSoftClick();
        } else if (e.key === "ArrowDown" || e.key.toLowerCase() === "s") {
          changeDirection("down");
          playSoftClick();
        } else if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") {
          changeDirection("left");
          playSoftClick();
        } else if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") {
          changeDirection("right");
          playSoftClick();
        } else if (e.key === " ") {
          if (state === STATE.RUNNING) {
            pauseGame();
          } else if (state === STATE.PAUSED) {
            resumeGame();
          }
        } else if (e.key.toLowerCase() === "r") {
          resetGame();
          startGame();
        } else if (e.key === "Enter") {
          if (state === STATE.IDLE || state === STATE.OVER || state === STATE.PAUSED) {
            startGame();
          }
        }
      });

      controlButtons.forEach((btn) => {
        const dir = btn.getAttribute("data-dir");
        const handler = (e) => {
          e.preventDefault();
          if (state === STATE.IDLE) {
            startGame();
          }
          changeDirection(dir);
          playSoftClick();
        };
        btn.addEventListener("click", handler);
        btn.addEventListener("touchstart", handler, { passive: false });
      });

      playButton.addEventListener("click", () => {
        if (state === STATE.PAUSED) {
          resumeGame();
        } else {
          startGame();
        }
      });

      pauseHintButton.addEventListener("click", () => {
        if (state === STATE.RUNNING) {
          pauseGame();
        } else if (state === STATE.PAUSED) {
          resumeGame();
        }
      });

      restartButton.addEventListener("click", () => {
        resetGame();
        startGame();
      });

      modeToggle.addEventListener("change", () => {
        isClassicWalls = modeToggle.checked;
        modeLabel.textContent = isClassicWalls ? "Classic" : "Wrap";
        modeToggleLabel.classList.toggle("active", isClassicWalls);

        const modeCard = modeLabel.closest(".score-card");
        modeCard.style.transform = "scale(1.05)";
        setTimeout(() => {
          modeCard.style.transform = "scale(1)";
        }, 90);

        if (state === STATE.RUNNING || state === STATE.PAUSED) {
          resetGame();
          startGame();
        }
      });

      soundToggle.addEventListener("change", () => {
        soundToggleLabel.classList.toggle("active", soundToggle.checked);
      });

      window.addEventListener("blur", () => {
        if (state === STATE.RUNNING) {
          pauseGame();
        }
      });

      loadBestScore();
      resetGame();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
